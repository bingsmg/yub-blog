# 数据结构复习

英文单词：fixed(固定)  aggregate(聚合) variable(可变的) 

#### 什么是数据结构：

一般来说，用计算机解决问题一个具体问题的时，大致需要经过下列几个步骤：

1. 首先从具体问题抽象出一个适当的数据模型；
2. 设计一个解决此数学模型的算法；
3. 编写程序，测试，调整直至得到最终解答；

但是，很多非数值问题没法用数学方程描述，例如：图书馆检索数目系统（计算机处理的对象之间存在着一种最简单的线性关系）、计算机和人对弈问题（处理的对象衍生成树根到叶子间寻找各种格局的问题）、多叉路交通灯管理问题（处理对象衍生成图染色问题）。
因此，数据结构，简单来说：就是一门研究非数值计算问题的程序设计问题中计算机的操作对象以及他们之间关系和操作等的学科。

> 程序设计的实质：对确定的问题选择一种好的结构，加上设计一种好的算法。

#### 专业术语：

- 数据：对客观事物的符号表示，CS中指所有能输入到计算机中并被计算机程序处理的符号总称；
- 数据元素：数据的基本单位，CS中作为一个整体进行考虑和处理，由若干数据项组成；
- 数据对象：性质相同的数据元素的集合，数据的子集；
- 数据结构：相互之间存在一种或多种特定关系的数据元素的集合；
- 结构（逻辑结构）：数据元素相互之间的关系（逻辑关系）；根据数据元素间的不同关系，通常有以下四类基本结构：
  - 集合：结构中的元素，除了==同属于一个集合==外，再没有其他关系；
  - 线性结构：数据元素间存在==一个对一个==的关系；
  - 树形结构：结构中的数据元素之间存在==一个对多个==的关系；
  - 图状结构（网状结构）：结构中的数据元素之间存在==多个对多个==的关系；

#### 在计算机中的表示：

数据结构在计算机中的表示（又称==映像==）称为数据的==物理结构==（存储结构），数据元素之间的关系在计算机中只有两种不同的表示方法：顺序映像 和 非顺序映像；由此得到两种存储结构：顺序存储结构 和 非顺序存储结构。

计算机中表示信息的最小单位是二进制的一位，叫做**位**，计算机中我们用一个由若干位组合起来的位串表示一个数据元素（如用8位表示一个字符），通常称这个位串为**元素**或**结点**，当数据元素由若干数据项组成时，位串中对应于各个数据项的子位串称为**数据域**。

> 任何一个好的算法的设计取决于选定的数据逻辑结构，算法的实现依赖于次啊用的存储结构。

数据类型：明显隐含在程序执行期间变量或表达式所有可能取值的范围，以及这些值上允许进行的操作。也就是一个值的集合和定义在这个值集上的一组操作的总称。高级程序语言中，数据类型分为类，分为：非结构的原子类（基本类型，指针，空类型等）和结构类型。
一般编程语言里，数据元素名（a,b,c,d,e)，整形变量名（i,j,k,l,m,n), 指针变量名（p,q,r)。

引入数据类型的目的：从硬件角度看，是作为解释计算机内存中信息含义的一种手段；对用户来说，实现信息隐蔽，将不必了解的细节封装在类型里。

#### 算法

算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中一条指令表示一个或多个操作。

五个重要特性：

1. 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成；
2. 确定性：算法中的每一条指令必须有确切的含义，读者理解不会产生二义性，并且在任何条件下，算法只有惟一的一条执行路径，即对于相同的输入只能得出相同输出；
3. 可行性：一个算法是能行的，即算法中描述的操作都是可以通多已经实现的基本运算执行有限次来实现的；
4. 输入：一个算法有零个或多个的输入，这些输入取自于某个特定对象的集合；
5. 输出：一个算法有一个或者多个输出，这些输出和同输入有着特定关系；

好的算法设计要求：

1. 正确性；
2. 可读性；
3. 健壮性；
4. 效率和低存储量需求；
   效率的度量一般采用==渐近时间复杂度==来描述，一般时间复杂度指最坏时间复杂度（因为平均时间复杂度难以确定）。存储量需求用空间复杂度描述，所需要的额外空间对于输入数据量来说是常数，则称此算法为**原地工作**



## 线性表

线性结构特点：

1. 存在唯一一个被称为第一个的数据元素；
2. 存在唯一一个被称为最后一个的数据元素；
3. 除第一个之外，集合中的每个数据元素均只有一个前驱；
4. 除最后一个之外，集合中的每个数据元素均只有一个后继；

线性表：是n个数据元素的有限序列。

复杂的线性表中，一个数据元素由若干个数据项组成，在此情况下，数据元素又称之为**记录**（record），含有大量记录的线性表称之为文件。

---



### 实现

顺序实现：**l**表示一个元素所占用的存储空间
$$
LOC(a_{i+1}) = LOC(a_i) + l
$$

```c++
#define LISTINCREMENT 10
#define LIST_INIT_SIZE 100
#define int ElemType

// 顺序表
typedef struct {
    ElemType *elem;
    int length;
    int listsize;
}SqList;

// 单链表
typedef struct LNode {
    ElemType data;
    struct LNode* next;
}LNode, *LinkList;
```

单链表由头指针唯一确定，有时候为了方便，可以在第一个节点前附设一个节点，称之为==头节点==，头结点的数据域可以不存任何东西，也可以存辅助信息，指针域存储指向第一个节点的指针。

#### 循环链表

操作和单链表基本一致，差别在于算法中循环条件判断不是p或者p->next是否为空，而是是否等于头指针。有时候在循环链表中设立尾指针而不设头指针，可以使操作简化。

#### 双向链表

结点中有两个指针域，一个指向直接后继，一个指向直接前驱。





## 栈

栈是限定在表尾进行插入或者删除操作的线性表。

表尾有特殊含义称之为==栈顶(top)==(非空栈的栈顶始终指向栈顶元素的下一个位置上)，表头称为栈底，不含元素的为空栈。



**FIFO：后进先出。**

#### 基本操作：

1. 栈顶插入；push()
2. 栈顶删除；pop()
3. 栈的初始化；
4. 判空；empty()
5. 取栈顶元素；top()

#### 应用：

1. 数值转换；
2. 括号匹配校验；
3. 行编辑程序；
4. 迷宫求解；
5. 表达式求值；
6. 递归栈的应用；

## 队列

队列是限定在表的一端进行插入，另一端进行删除的线性表。

**FIFO：先进先出。**

允许插入的一端叫==队尾(rear)==，允许删除的一端叫==队头(front)==。

#### 双端队列

限定插入删除在两端进行。

#### 循环队列

将顺序队列臆造称一个环状的空间，称之为循环队列。

但是这样不能根据`Q.front == Q.rear`判断队列是否为空或满，有两种处理办法：

1. 另设一个标志位以区别队列为“空”，还是“满”；
2. 少用一个元素空间，约定队列头指针在队列尾指针的下一位置上作为队列呈“满”状态标识。

```cpp
typedef ElemType* List;

#define MAXSIZE 100
typedef struct {
    int* base;
    int front;
    int rear;
}SqQueue;

int InitQueue(SqQueue &Q) {
    Q.base = (int *)malloc(sizeof(int) * MAXSIZE);
    if (!Q.base) exit(OVERFLOW);
    Q.front = Q.rear = 0;
    return OK;
}

int QueueLength(SqQueue Q) {
    return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
}

// 规定front永远在rear的下一位置，少用一个元素空间
int EnQueue(SqQueue &Q, int e) {
    if ((Q.rear+1) % MAXSIZE == Q.front) return ERROR;
    Q.base[Q.rear] = e;
    Q.rear = (Q.rear+1) % MAXSIZE;
    return OK;
}

int DeQueue(SqQueue &Q, int &e) {
    if (Q.rear == Q.front) return ERROR;
    e = Q.base[Q.front];
    Q.front = (Q.front + 1) % MAXSIZE;
    return OK;
}
```

#### 链队列



## 串

字符串一般简称串。
**串**是由零个或者多个字符组成的有线序列。       **s = 'a~1~a~2~a~3~...a~n~'**

串中字符的数目n称之为串的长度。零个字符串的串称为**空串**。串中任意连续个字符组成的子序列为该串的**子串**，串相等则当且仅当两个串的值相等，各个位置对应的字符都是相等。

串的存储：**定长数组存储**表示，**堆分配存储**表示，**块链存储**表示（每一个节点可以存多个字符，附设尾指针指示出串的长度），块链存储中，我们考虑串的存储密度
$$
存储密度 = \frac{串值所占的存储位}{实际分配的存储位}
$$
串长的表示：一是以数组下标为0的数据分量存放串的实际长度；二是在串值后面加一个不计入串长的结束标记字符，C语言以**‘\0’** 表示串的终结。

---



#### 串的基本操作：

1. 串赋值：StrAssign
2. 串比较：StrCompare
3. 求串长：StrLength
4. 串联接：Concat
5. 求子串：SubString

#### 串的模式匹配算法：

BF算法：每次匹配不成功就回溯i指针和j指针，最坏时间复杂度O(n*m)；

```cpp
int Index(String S, String T, int pos) {
    int i = pos;
    int j = 0;
    while (i < S.length() && j < T.length()) {
        if (S[i] == T[j]) {
            ++i;
            ++j;
        } else {
            i = i-j+1;
            j = 0;
        }
    }
    if (j >= T.length()) return i-T.length();
    else return 0;
}
```

KMP算法：不回溯i指针，利用已经得到的“部分匹配”结果将模式向右尽可能”滑动“远的一段距离后再比较。

```cpp

```



#### 串的应用：

1. 文本编辑；
2. 建立词索引表；



## 数组和广义表

数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。

数组和广义表可以看成是线性表在下述含义上的扩展：**表中的数据元素本身也是一个数据结构。**

> 我们可以把二维数组堪称这样一个定长线性表：它的每个数据元素也是一个线性表。

存储结构是一维的，但是数组是多维的，所以用一组连续存储单元存放数组的数据元素有次序问题：

1. 行序为主；
2. 列序为主；主要在FORTRAN语言中

只讨论以行序为主的存储结构，假设每个数据元素占用L个存储单元，则二维数组A中任意一个元素a~ij~的存储位置可有下式确定：
$$
LOC(i,j) = LOC(0,0) + (bi+j)L
$$
由二维可以推广到n维。

---

#### 矩阵的压缩存储

矩阵是很多科学与工程计算问题中研究的数学对象。高级语言编制程序时拿二维数组存储矩阵元。

一些阶数很高的矩阵中，有很多值相同的元素或者时零元素，为了节省存储空间，可以对此类矩阵**压缩存储**。

> 压缩存储：为多个值相同的元只分配一个存储空间；对零元不分配空间。

假若值相同的元素或者零元素在矩阵中的分布由一定规律，则我们称此类矩阵为**特殊矩阵**，反之称之为**稀疏矩阵**。

- 特殊矩阵：在这些矩阵里，非零元的分布由一个明显的规律，从而我们可以压缩到一维数组中，并找到每个非零元在一维数组中的对应关系。

- 稀疏矩阵：非零元较零元少，且分布没有一定规律，这类压缩比较复杂。假设在m X n 的矩阵中，有t个元素不为零。令  $\delta = \frac{t}{{m}\times{n}}$ 称$\delta$为矩阵的稀疏因子，认为 $\delta$<=0.05 时称为稀疏矩阵。

---

存储表示：

```cpp
typedef struct {
    int i, j;  // 非零元的行列下标
    ElemType e;  // 非零元
}Triple;

typedef struct {
    Triple data[MAXSIZE+1];
    int mu, nu, tu;  // 矩阵的行数，列数，非零元个数
}TSMatrix;
```

稀疏矩阵转置：

1. 将矩阵的行列值互换；
2. 将每个三元组里面的i和j互相调换；
3. 重排三元组的次序；

如何重排：
一，按照b.data中的三元组的次序依次在a.data中找到相应的三元组进行转置。也就是按照M的列序转置。

```cpp
Status TransposeSMatrix(TSMatrix M, TSMatrix &T) {
    T.mu = M.nu, T.nu = M.mu, T.tu = M.tu;
    if (T.tu) {
        q = 1;
        for (col = 1; col <= M.nu; ++col) {  // 从第一列开始遍历所有列
            for (p = 1; p <= M.tu; ++p) {  // 扫描整个三元组表
                if (M.data[p].j == col) {  // 找到每一列的每个元素
                    T.data[q].i = M.data[p].j;
                    T.data[q].j = M.data[p].i;
                    T.data[q].e = M.data[p].e;
                    ++q;  // 转置后T三元组表的行
                }
            }
        }
    }
}
```

此算法两层循环时间复杂度为$O({{m}\times{n}})$ ，当非零元个数tu和${{mu}\times{nu}}$ 同数量级时，时间复杂度变为 $O({mu}\times{{nu}^2})$ 因此此算法只适用于  tu << mu X nu的情况。

二，按照a.data中三元组的次序进行转置，并将转置后的三元组置入b中恰当的位置，如果可以预先确定矩阵M中每一列（T中的每一行）的第一个非零元在b.data中应有的位置，那么在对a.data中的三元组依次转置时，便可直接放到b.data中恰当的位置上去。







## 树和二叉树

树(Tree)是n(n >= 0)个结点的有限集。在任意一个非空树中 ：

1. 有且仅有一个特定的称为根(Root)的结点；
2. 当n > 1时，其余结点可分为m(m > 0)个互不相交的有限集T~1~,T~2~...T~m~，其中每一个集合本身又是一棵树，称为根的子树（SubTree）;

#### 基本概念：

1. 度（degree）：结点拥有的子树数称为结点的度;
2. 叶子结点（Leaf）：度为0的结点；
3. 树的度：树内各结点的度的最大值；
4. 孩子（Child）：结点的子树的根；
5. 双亲（Parent）：该结点称为孩子的双亲；
6. 兄弟（Sibling）：同一个双亲的孩子；
7. 层次（level）：从根开始定义，根为第一层，根的孩子第二层递增；
8. 深度（Depth）：树中结点的最大层次；
9. 森林（Forest）：m(m >= 0)棵互不相交的树的集合；

#### 二叉树（Binary Tree）：

特点：每个结点至多只有两颗子树（不存在度大于2的结点），并且子树有左右之分，次序不能颠倒。

完全二叉树：满二叉树每一个结点都与满二叉树中编号1-n的结点对应

满二叉树：一颗深度为k且有2^k^-1个节点的二叉树；

完美二叉树：

性质：

1. 在第i层上至多有2^i-1^个结点（i>=1）;
2. 深度为k的二叉树至多有2^k^-1个结点；
3. 任意二叉树，叶子结点数为n~0~，度为2的结点为n~2~，则 $n_0 = n_2 + 1$
   证明：n个结点的树有n-1条边，设n~0~，n~1~，n~2~表示度为0，1，2的点的个数，则总节点数=n~0~+n~1~+n~2~=2n~2~+n1+1，消掉等式则n~0~=n~2~+1。
4. 



